# SPDX-License-Identifier: GPL-2.0-or-later

#
# Copyright (C)   2011        by Karl Kurbjun
# Copyright (C)   2009        by David Brownell
#

# Utilities for TI ICEPick-C/D used in most TI SoCs
# A datasheet for the ICEPick TAP Router Module Type C can be found at
# https://web.archive.org/web/20221215094344/https://www.ti.com/lit/ug/spruh35/spruh35.pdf?ts=1670785155424
#
# The process to set up the ICEPick so that actual debugging is possible is listed for the ICEPick
# Type C at:
# https://web.archive.org/web/20221215094720/https://downloads.ti.com/ccs/esd/documents/xdsdebugprobes/files/Router_Scan_Sequence.pdf
#
# For the ICEPick Type D it is listed at:
# https://web.archive.org/web/20221215095449/https://downloads.ti.com/ccs/esd/documents/xdsdebugprobes/files/Router_Scan_Sequence-ICEpick-D.pdf

# Get instruction number by name
proc INSTR { key } {
	array set constant {
		ROUTER          0x02
		ID_CODE         0x04
		ICEPICK_CODE    0x05
		CONNECT         0x07
		BYPASS          0x3F
	}
	return $constant($key)
}

# Get system control register fields /constants by name
proc SYS_CNTL { key } {
	array set constant {
		FREE_RUNNING_TCK                0x001000
		KEEP_POWER_IN_TLR               0x000080
		DEVICE_TYPE_TEST                0x000000
		DEVICE_TYPE_EMULATOR            0x000002
		DEVICE_TYPE_SECURE              0x000004
		DEVICE_TYPE_GENERAL_PURPOSE     0x000006
		SYS_RESET                       0x000001
	}
	return $constant($key)
}

# Get secondary debug TAP register fields /constants by name
proc SDTAP { key } {
	array set constant {
		POWER_LOSS_DETECTED             0x200000
		INHIBIT_SLEEP                   0x100000
		TAP_POWER                       0x080000
		UNNATURAL_RESET                 0x040000
		IN_RESET                        0x020000
		RELEASE_FROM_WAIT_IN_RESET      0x020000
		RESET_MODE_NORMAL               0x000000
		RESET_MODE_WAIT_IN_RESET        0x004000
		RESET_MODE_BLOCK_RESET          0x008000
		RESET_MODE_ASSERT_AND_HOLD      0x00C000
		DEBUG_CONNECT                   0x002000
		DEBUG_MODE_DEFAULT              0x000000
		DEBUG_MODE_MONITOR              0x000800
		DEBUG_MODE_STOP                 0x001000
		DEBUG_MODE_REAL_TIME            0x001800
		DEBUG_ATTENTION                 0x000400
		TAP_VISIBLE                     0x000200
		TAP_SELECT                      0x000100
		POWER_DOWN_DESIRED              0x000080
		FORCE_POWER                     0x000040
		POWER                           0x000020
		CLOCK_DOWN_DESIRED              0x000010
		FORCE_ACTIVE                    0x000008
		CLOCK                           0x000004
		TAP_ACCESSIBLE                  0x000002
		TAP_PRESENT                     0x000001
	}
	return $constant($key)
}

# Get router register numbers
proc REG { key } {
	array set constant {
		ZERO            0x00
		SYS_CNTL        0x01
		SDTAP0          0x20
		SDTAP1          0x21
		SDTAP2          0x22
		SDTAP3          0x23
		SDTAP4          0x24
		SDTAP5          0x25
		SDTAP6          0x26
		SDTAP7          0x27
		SDTAP8          0x28
		SDTAP9          0x29
		SDTAP10         0x2A
		SDTAP11         0x2B
		SDTAP12         0x2C
		SDTAP13         0x2D
		SDTAP14         0x2E
		SDTAP15         0x2F
		CORE_ID0        0x60
		CORE_ID1        0x61
		CORE_ID2        0x62
		CORE_ID3        0x63
		CORE_ID4        0x64
		CORE_ID5        0x65
		CORE_ID6        0x66
		CORE_ID7        0x67
		CORE_ID8        0x68
		CORE_ID9        0x69
		CORE_ID10       0x6A
		CORE_ID11       0x6B
		CORE_ID12       0x6C
		CORE_ID13       0x6D
		CORE_ID14       0x6E
		CORE_ID15       0x6F
	}
	return $constant($key)
}

# Get the secondary debug TAP register by the TAP number
proc REG_SDTAP { tapnum } {
	if { $tapnum < 0 || $tapnum > 15 } {
		echo "Error: Invalid TAP number $tapnum"
		return [REG ZERO]
	}
	return [expr {[REG SDTAP0] + $tapnum}]
}

# Get the core ID register by the core number
proc REG_CORE_ID { corenum } {
	return [expr {[REG CORE_ID0] + $corenum}]
}

# Get constants for the 8 bit Debug Connect register that is accessed via the CONNECT instruction
proc CONNECT { key } {
	array set constant {
		WRITE_ENABLE    0x80
		KEY_CONNECT     0x09
		KEY_DISCONNECT  0x06
	
	}
	return $constant($key)
}

# Get ICEPick model
proc MODEL { code } {
	if { $code == 0x1CC } {
		return "C"
	}

	return "unknown"
}

# Get capability codes
proc CAPABILITY { key } {
	array set constant {
		CLOCK_VOTING        0x02
		REDUCED_TCK_MODE    0x01
	}
	return $constant($key)
}

variable _icepick_already_done 0

# Instruction to connect to the icepick module
proc icepick_c_connect {jrc} {
	# Send CONNECT instruction in IR state
	irscan $jrc [INSTR CONNECT] -endstate IRPAUSE

	# Send write and connect key to the 8 bit debug connect register
	drscan $jrc 8 [expr {[CONNECT WRITE_ENABLE] | [CONNECT KEY_CONNECT]}]  -endstate DRPAUSE
}

# Instruction to disconnect to the icepick module
proc icepick_c_disconnect {jrc} {

	# Send CONNECT instruction in IR state
	irscan $jrc [INSTR CONNECT] -endstate IRPAUSE

	# Send write and disconnect key to the 8 bit debug connect register
	drscan $jrc 8 [expr {[CONNECT WRITE_ENABLE] | [CONNECT KEY_DISCONNECT]}]  -endstate DRPAUSE
}

# icepick_c_router_rw:
#  this function is for accessing router registers
# arguments are:
#  jrc:        TAP name for the ICEpick
#  rw:         read/write (0 for read, 1 for write)
#  register:   which register to read/write
#  payload:    value to read/write
# return value:
#  old register value
proc icepick_c_router_rw {jrc rw register payload} {

	set new_dr_value \
		[expr { ( ($rw & 0x1) << 31) | \
				( ($register & 0x7F) << 24) | \
				( $payload & 0xFFFFFF ) } ]

	# select router
	irscan $jrc [INSTR ROUTER] -endstate IRPAUSE

	return [expr {"0x[drscan $jrc 32 $new_dr_value -endstate DRPAUSE]"}]
}

# icepick_c_router_write:
#  this function is for writing to router registers
# arguments are:
#  jrc:        TAP name for the ICEpick
#  register:   which register to read/write
#  payload:    value to read/write
# return value:
#  1 on success, 0 on failure
proc icepick_c_router_write {jrc register payload} {
	icepick_c_router_rw $jrc 1 $register $payload
}

# icepick_c_router_read:
#  this function is for reading router registers
# arguments are:
#  jrc:        TAP name for the ICEpick
#  register:   which register to read/write
# return value:
#  the value read
proc icepick_c_router_read {jrc register} {
	# issue the read command
	icepick_c_router_rw $jrc 0 $register 0x000000
	# issue a bogus read command to fetch the reply from the last read command
	return [icepick_c_router_rw $jrc 0 [REG ZERO] 0x000000]
}

proc icepick_c_detect {jrc} {
	irscan $jrc [INSTR ID_CODE] -endstate IRPAUSE
	set idcode [expr {"0x[drscan $jrc 32 0x00000000 -endstate DRPAUSE]"}]
	set version [expr {$idcode >> 28}]
	set part [expr {($idcode >> 12) & 0xFFFF}]
	set manufacturer [expr {($idcode >> 1) & 0x7FF}]
	if {$manufacturer != 0x017} {
		echo "Error: This is not an ICEPick JTAG router, wrong manufacturer code!"
		return 0
	}

	irscan $jrc [INSTR ICEPICK_CODE] -endstate IRPAUSE
	set ipcode [expr {"0x[drscan $jrc 32 0x00000000 -endstate DRPAUSE]"}]
	set version_major [expr {$ipcode >> 28}]
	set version_minor [expr {($ipcode >> 24) & 0xF}]
	set testtaps [expr {($ipcode >> 20) & 0xF}]
	set emutaps [expr {($ipcode >> 16) & 0xF}]
	set type [expr {($ipcode >> 4) & 0xFFF}]
	set capabilities [expr {$ipcode & 0xF}]

	echo "Info : Detected ICEPick model [MODEL $type] version [format %d.%02d $version_major $version_minor]"
	echo "Info : ICEPick supports $testtaps test-only TAPs and $emutaps emulation/debug TAPs, capabilities: 0x[format %x $capabilities]"

	return 1
}

# Configure the icepick control register
proc icepick_c_setup {jrc} {

	# send a router write, block is 0, register is 1
	icepick_c_router_write $jrc [REG SYS_CNTL] [expr { \
			[SYS_CNTL FREE_RUNNING_TCK] | \
			[SYS_CNTL KEEP_POWER_IN_TLR] } ]
}

# Configure an ICEPick JTAG Router Type C to attach the given TAP to the
# scan chain and put the JTAG Router in bypass mode
# arguments:
#   jrc:            TAP name for the ICEpick
#   port:           port number, 0..15 for debug tap, 16..31 for test tap
proc icepick_c_tapenable { jrc port } {
	global _icepick_already_done

	set register [REG_SDTAP $port]
	if { $register == [REG ZERO] } {
		return
	}

	# On the first tap-enable event we place the MCU tap in wait-in-reset. In the
	# second invocation, we release it from reset.
	set reset_mode [SDTAP RELEASE_FROM_WAIT_IN_RESET]

	# Verify that we actually have a ICEPick Model C
	if { $_icepick_already_done != 1 } {
		if { 0 == [icepick_c_detect $jrc] } {
			return
		}
		set reset_mode [SDTAP RESET_MODE_WAIT_IN_RESET]
	}

	# First CONNECT to the ICEPick.
	# The datasheet says, send 6 bit cmd '0x00000007' followed by
	# 8 bit value '0x00000089'; this is writing the connect key to the debug
	# connect register.
	icepick_c_connect $jrc

	# Now datasheet says send 6 bit command '0x00000002' and 32 bit data value
	# '0xa<P>002108', where <P> is the TAP number. This is a ROUTER command
	# followed by writing to the SDTAP<P> register with the following config:
	# - reset mode: normal
	# - debug mode: default
	# - debug connect: on
	# - tap select: on
	# - force active: on
	icepick_c_router_write $jrc $register [expr { \
			[SDTAP DEBUG_CONNECT] | \
			[SDTAP TAP_SELECT ] | \
			$reset_mode | \
			[SDTAP DEBUG_MODE_DEFAULT] | \
			[SDTAP FORCE_ACTIVE] }]

	# Finally, a 6 bit "all ones" command is to be send and for the duration
	# of at least 10 TCK pulses waited. The all-one instruction is the bypass
	# instruction, which allows communicating with the target JTAG TAP
	# afterwards
	irscan $jrc [INSTR BYPASS] -endstate RUN/IDLE

	set _icepick_already_done 1

	runtest 10
}

# jrc	== TAP name for the ICEpick
# coreid== core id number 0..15 (not same as port number!)
proc icepick_d_set_core_control {jrc coreid value} {
	icepick_c_router_write $jrc [REG_CORE_ID $coreid] $value
}

# jrc	== TAP name for the ICEpick
# port	== a port number, 0..15
# Follow the sequence described in
# http://processors.wiki.ti.com/images/f/f6/Router_Scan_Sequence-ICEpick-D.pdf
proc icepick_d_tapenable {jrc port coreid { value 0x2008 }} {
	set register [REG_SDTAP $port]
	if { $register == [REG ZERO] } {
		return
	}

	# First CONNECT to the ICEPick
	icepick_c_connect $jrc
	icepick_c_setup $jrc

	# Select the port
	icepick_c_router_write $jrc $register [expr { \
			[SDTAP DEBUG_CONNECT] | \
			[SDTAP TAP_SELECT ] | \
			[SDTAP RESET_MODE_NORMAL] | \
			[SDTAP DEBUG_MODE_DEFAULT] | \
			[SDTAP FORCE_ACTIVE] }]

	# Set icepick core control for $coreid
	icepick_d_set_core_control $jrc $coreid $value

	# Enter the bypass state
	irscan $jrc [INSTR BYPASS] -endstate RUN/IDLE
	runtest 10
}

# This function uses the ICEPick to send a warm system reset
proc icepick_c_wreset {jrc} {
	icepick_c_router_write $jrc [REG SYS_CNTL] [expr { \
			[SYS_CNTL FREE_RUNNING_TCK] | \
			[SYS_CNTL KEEP_POWER_IN_TLR] | \
			[SYS_CNTL SYS_RESET] }]
}

# Change the reset mode of the TAP
# arguments:
#   jrc:            TAP name for the ICEpick
#   port:           port number, 0..15 for debug tap, 16..31 for test tap
#   reset_mode:     new reset mode
proc icepick_c_change_reset_mode { jrc port reset_mode} {
	set register [REG_SDTAP $port]
	if { $register == [REG ZERO] } {
		return
	}
	icepick_c_router_write $jrc $register [expr { \
			[SDTAP DEBUG_CONNECT] | \
			[SDTAP TAP_SELECT ] | \
			$reset_mode | \
			[SDTAP DEBUG_MODE_DEFAULT] | \
			[SDTAP FORCE_ACTIVE] }]
}

# release a TAP that is held in wait-in-reset state
# arguments:
#   jrc:            TAP name for the ICEpick
#   port:           port number, 0..15 for debug tap, 16..31 for test tap
proc icepick_c_release_from_wait_in_reset { jrc port } {
	icepick_c_change_reset_mode $jrc $port [SDTAP RELEASE_FROM_WAIT_IN_RESET]
}
